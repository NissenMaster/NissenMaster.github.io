<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo 指令</title>
    <url>/2020/03/20/hexo-%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h5 id="1-hexo-server"><a href="#1-hexo-server" class="headerlink" title="1. hexo server"></a>1. hexo server</h5><p>   Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p>
<h5 id="2-hexo-server-s"><a href="#2-hexo-server-s" class="headerlink" title="2. hexo server -s"></a>2. hexo server -s</h5><p>   以静态模式启动</p>
<h5 id="3-hexo-server-p-5000"><a href="#3-hexo-server-p-5000" class="headerlink" title="3. hexo server -p 5000"></a>3. hexo server -p 5000</h5><p>更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p>
<h5 id="4-hexo-server-i-IP地址"><a href="#4-hexo-server-i-IP地址" class="headerlink" title="4. hexo server -i IP地址"></a>4. hexo server -i IP地址</h5><p>自定义 IP</p>
<h5 id="5-hexo-clean"><a href="#5-hexo-clean" class="headerlink" title="5. hexo clean"></a>5. hexo clean</h5><p>清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p>
<h5 id="6-hexo-g"><a href="#6-hexo-g" class="headerlink" title="6. hexo g"></a>6. hexo g</h5><p>生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</p>
<h5 id="7-hexo-d"><a href="#7-hexo-d" class="headerlink" title="7. hexo d"></a>7. hexo d</h5><p>将本地数据部署到远端服务器(如github)</p>
<h5 id="8-hexo-init-文件夹名称"><a href="#8-hexo-init-文件夹名称" class="headerlink" title="8. hexo init 文件夹名称"></a>8. hexo init 文件夹名称</h5><p>初始化XX文件夹名称</p>
<h5 id="9-npm-update-hexo-g"><a href="#9-npm-update-hexo-g" class="headerlink" title="9. npm update hexo -g"></a>9. npm update hexo -g</h5><p>升级</p>
<h5 id="10-npm-install-hexo-g"><a href="#10-npm-install-hexo-g" class="headerlink" title="10. npm install hexo -g"></a>10. npm install hexo -g</h5><p>安装</p>
<h5 id="11-node-v"><a href="#11-node-v" class="headerlink" title="11. node-v"></a>11. node-v</h5><p>查看node.js版本号</p>
<h5 id="12-npm-v"><a href="#12-npm-v" class="headerlink" title="12. npm -v"></a>12. npm -v</h5><p>查看npm版本号</p>
<h5 id="13-git-–version"><a href="#13-git-–version" class="headerlink" title="13. git –version"></a>13. git –version</h5><p>查看git版本号</p>
<h5 id="14-hexo-v"><a href="#14-hexo-v" class="headerlink" title="14. hexo -v"></a>14. hexo -v</h5><p>查看hexo版本号</p>
<h5 id="15-hexo-publish-layout"><a href="#15-hexo-publish-layout" class="headerlink" title="15. hexo publish [layout] "></a>15. hexo publish [layout] <title></title></h5><p>通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] <title>,草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。</title></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-03-15</title>
    <url>/2020/03/15/2019-03-15/</url>
    <content><![CDATA[<h5 id="1-创建一个数组，同时生成一个2-32之间的随机数插入数组当中，且不能重复，请使用递归输出一个长度为5且不重复的数组。"><a href="#1-创建一个数组，同时生成一个2-32之间的随机数插入数组当中，且不能重复，请使用递归输出一个长度为5且不重复的数组。" class="headerlink" title="1. 创建一个数组，同时生成一个2-32之间的随机数插入数组当中，且不能重复，请使用递归输出一个长度为5且不重复的数组。"></a>1. 创建一个数组，同时生成一个2-32之间的随机数插入数组当中，且不能重复，请使用递归输出一个长度为5且不重复的数组。</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">const</span> getRand = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">32</span> - <span class="number">2</span>) + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> insertToArr = <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            !arr.includes(num) &amp;&amp; arr.push(num);</span><br><span class="line">            insertToArr(getRand());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    insertToArr(getRand())</span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">// [31, 6, 25, 5, 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-通过使用-reduce-进行数组的扁平化处理。"><a href="#2-通过使用-reduce-进行数组的扁平化处理。" class="headerlink" title="2. 通过使用 reduce 进行数组的扁平化处理。"></a>2. 通过使用 reduce 进行数组的扁平化处理。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [ <span class="number">8</span>, [ <span class="number">9</span>, [<span class="number">10</span>, [<span class="number">11</span>, [<span class="number">12</span>, [<span class="number">13</span>, [<span class="number">14</span>, <span class="number">15</span>], <span class="number">16</span>], <span class="number">17</span>], <span class="number">18</span>], <span class="number">19</span>]], <span class="number">20</span>]]];</span><br><span class="line">    <span class="keyword">const</span> bph = <span class="function"><span class="params">data</span> =&gt;</span> data.reduce(<span class="function">(<span class="params">item, current</span>) =&gt;</span> item.concat(<span class="built_in">Array</span>.isArray(current) ? bph(current) : current), []);</span><br><span class="line">    <span class="keyword">const</span> result = bph(arr);</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-简述-CSS-盒子模型"><a href="#3-简述-CSS-盒子模型" class="headerlink" title="3. 简述 CSS 盒子模型"></a>3. 简述 CSS 盒子模型</h4><p>Box Model，所有的 html 元素都可以看做是盒子，整体包括：边距，边框，填充，和实际内容。<br>由外向里依次是：margin(外边距) -&gt; border(边宽) -&gt; padding(内边距) -&gt; 内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-什么时候需要清除浮动？为什么？有哪些方法？"><a href="#4-什么时候需要清除浮动？为什么？有哪些方法？" class="headerlink" title="4. 什么时候需要清除浮动？为什么？有哪些方法？"></a>4. 什么时候需要清除浮动？为什么？有哪些方法？</h4><p>当子元素设置了float属性之后，且父元素的高度和宽度没有进行设置，而是由子元素支撑起来，则会导致父元素的高度塌陷;<br>清除浮动有两种方法： </p>
<ul>
<li><p>clear 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>overflow 属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-display-和-position-的区别"><a href="#5-display-和-position-的区别" class="headerlink" title="5. display 和 position 的区别"></a>5. display 和 position 的区别</h4><p>display：可以理解为在一个框内的元素的陈列方式，常用的常用的值有flex、none、inline、block、inline-block； </p>
<p>position：定位，可以使相对的也可以是绝对的；</p>
<ol>
<li><p>absolute    生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>fixed    生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
</li>
<li><p>relative    生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</p>
</li>
</ol>
<ol start="4">
<li><p>static    默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
</li>
<li><p>inherit    规定应该从父元素继承 position 属性的值。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>四菜一汤</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>dva-loading</title>
    <url>/2019/10/22/dva-loading/</url>
    <content><![CDATA[<p>关于页面 loading 的问题，我们最初的方法是手动更新 loading：是在 redux 的 state 中增加 loading 变量，给其设定默认值，当执行调用接口的方法时，先改变一次 loading 的值，执行完成之后再改变一次。<br>这个方法虽然可以解决页面 loading 的问题的，但是这种做法非常的啰嗦且不优雅。于是我们就引入了 dva-loading。<br>dva-loading 其实只是异步执行方法的状态，并不是真正意义上的 loading，我们只是通过异步执行方法的状态给各组件自身控制 loading 渲染提供数据。</p>
<h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 index.js 文件</span></span><br><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"><span class="keyword">import</span> createLoading <span class="keyword">from</span> <span class="string">'dva-loading'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = dva(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">app.use(createLoading());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例文件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line"></span><br><span class="line">@connect(<span class="function">(<span class="params">&#123; loading &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  loading: loading.effects[<span class="string">'test/fetch'</span>], <span class="comment">// 监听单一异步请求状态</span></span><br><span class="line">&#125;))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loading &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Spin spinning=&#123;loading&#125;&gt;</span><br><span class="line">        &lt;h1&gt;<span class="number">666666</span>&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Spin&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>dva</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题一</title>
    <url>/2019/10/22/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</url>
    <content><![CDATA[<h4 id="1-页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#1-页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="1.页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>1.页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h4><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>
<h4 id="2-浏览器工作原理"><a href="#2-浏览器工作原理" class="headerlink" title="2.浏览器工作原理"></a>2.浏览器工作原理</h4><p>1.用户界面 2.网络 3.UI后端 4.数据存储 5.浏览器引擎 6.渲染引擎 7.js解释器</p>
<h4 id="3-浏览器解析过程："><a href="#3-浏览器解析过程：" class="headerlink" title="3.浏览器解析过程："></a>3.浏览器解析过程：</h4><p>流程：解析html以构建dom树-&gt;构建render树-&gt;布局render树-&gt;绘制render树</p>
<h4 id="4-介绍一下你对浏览器内核的理解？"><a href="#4-介绍一下你对浏览器内核的理解？" class="headerlink" title="4.介绍一下你对浏览器内核的理解？"></a>4.介绍一下你对浏览器内核的理解？</h4><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。</p>
<p>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>JS引擎则：解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h4 id="5-常见的浏览器内核有哪些？"><a href="#5-常见的浏览器内核有哪些？" class="headerlink" title="5.常见的浏览器内核有哪些？"></a>5.常见的浏览器内核有哪些？</h4><p>Trident内核：IE,360，傲游，搜狗，世界之窗，腾讯等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]</p>
<h4 id="6-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#6-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="6.请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>6.请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。<br>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，<br>可以达到5M或更大。<br>有期时间：<br>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<h4 id="7-请大概描述下页面访问cookie的限制条件"><a href="#7-请大概描述下页面访问cookie的限制条件" class="headerlink" title="7.请大概描述下页面访问cookie的限制条件"></a>7.请大概描述下页面访问cookie的限制条件</h4><p>跨域问题，设置了HttpOnly。</p>
<h4 id="8-如何实现浏览器内多个标签页之间的通信-阿里"><a href="#8-如何实现浏览器内多个标签页之间的通信-阿里" class="headerlink" title="8.如何实现浏览器内多个标签页之间的通信? (阿里)"></a>8.如何实现浏览器内多个标签页之间的通信? (阿里)</h4><p>调用localstorge、cookies等本地存储方式</p>
<h4 id="9-页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#9-页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="9.页面可见性（Page Visibility API） 可以有哪些用途？"></a>9.页面可见性（Page Visibility API） 可以有哪些用途？</h4><p>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</p>
<h4 id="10-网页验证码是做什么的，是为了解决什么安全问题。"><a href="#10-网页验证码是做什么的，是为了解决什么安全问题。" class="headerlink" title="10.网页验证码是做什么的，是为了解决什么安全问题。"></a>10.网页验证码是做什么的，是为了解决什么安全问题。</h4><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</p>
<h4 id="11-为什么利用多个域名来存储网站资源？"><a href="#11-为什么利用多个域名来存储网站资源？" class="headerlink" title="11.为什么利用多个域名来存储网站资源？"></a>11.为什么利用多个域名来存储网站资源？</h4><p>CDN缓存更方便 ，突破浏览器并发限制<br>节约cookie带宽 ，节约主域名的连接数，优化页面响应速度 防止不必要的安全问题</p>
<h4 id="12-谈一下你对网页标准和标准制定机构重要性的理解。"><a href="#12-谈一下你对网页标准和标准制定机构重要性的理解。" class="headerlink" title="12.谈一下你对网页标准和标准制定机构重要性的理解。"></a>12.谈一下你对网页标准和标准制定机构重要性的理解。</h4><p>网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。</p>
<h4 id="13-知道什么是微格式吗？"><a href="#13-知道什么是微格式吗？" class="headerlink" title="13.知道什么是微格式吗？"></a>13.知道什么是微格式吗？</h4><p>微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式</p>
<p>优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。</p>
<h4 id="14-一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#14-一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="14.一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。"></a>14.一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h4><p>（1）图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。<br>（2）如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。<br>（3）如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。<br>（4）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p>
<h4 id="15-谈谈以前端角度出发做好SEO（搜索引擎）需要考虑什么？"><a href="#15-谈谈以前端角度出发做好SEO（搜索引擎）需要考虑什么？" class="headerlink" title="15.谈谈以前端角度出发做好SEO（搜索引擎）需要考虑什么？"></a>15.谈谈以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h4><p>合理的标签使用， 主要的互联网目录，链接交换和链接广泛度。</p>
<h4 id="16-请写出一些前端性能优化的方式，越多越好"><a href="#16-请写出一些前端性能优化的方式，越多越好" class="headerlink" title="16.请写出一些前端性能优化的方式，越多越好"></a>16.请写出一些前端性能优化的方式，越多越好</h4><p>1.减少dom操作<br>2.部署前，图片压缩，代码压缩<br>3.优化js代码结构，减少冗余代码<br>4.减少http请求，合理设置 HTTP缓存<br>5.使用内容分发cdn加速<br>6.静态资源缓存<br>7.图片延迟加载</p>
<h4 id="17-描述一下渐进增强和优雅降级之间的不同"><a href="#17-描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="17.描述一下渐进增强和优雅降级之间的不同?"></a>17.描述一下渐进增强和优雅降级之间的不同?</h4><p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p>
<h4 id="18-webSocket如何兼容低浏览器？-阿里"><a href="#18-webSocket如何兼容低浏览器？-阿里" class="headerlink" title="18.webSocket如何兼容低浏览器？(阿里)"></a>18.webSocket如何兼容低浏览器？(阿里)</h4><p>Adobe Flash Socket 、<br>ActiveX HTMLFile (IE) 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR</p>
<h4 id="19-web开发中会话跟踪的方法有哪些"><a href="#19-web开发中会话跟踪的方法有哪些" class="headerlink" title="19.web开发中会话跟踪的方法有哪些"></a>19.web开发中会话跟踪的方法有哪些</h4><p>1.cookie 2.session<br>2.url重写 4.隐藏input 5.ip地址</p>
<h4 id="20-HTTP-method"><a href="#20-HTTP-method" class="headerlink" title="20.HTTP method"></a>20.HTTP method</h4><p>1.一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。<br>2.GET是最常用的方法，通常用于请求服务器发送某个资源。<br>3.HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分。<br>4.PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它。<br>5.POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。<br>6.TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。<br>7.OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。<br>8.DELETE请求服务器删除请求URL指定的资源。</p>
<h4 id="21-HTTP-response报文结构是怎样的"><a href="#21-HTTP-response报文结构是怎样的" class="headerlink" title="21.HTTP response报文结构是怎样的"></a>21.HTTP response报文结构是怎样的</h4><p>rfc2616中进行了定义：<br>1.首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF<br>2.首行之后是若干行响应头，包括：通用头部，响应头部，实体头部<br>3.响应头部和响应实体之间用一个CRLF空行分隔</p>
<h4 id="22-HTTP状态码及其含义"><a href="#22-HTTP状态码及其含义" class="headerlink" title="22.HTTP状态码及其含义"></a>22.HTTP状态码及其含义</h4><p>状态码类型<br>状态码 类别 原因短语<br>1XX Information（信息性状态码） 接收的请求正在处理<br>2XX Success（成功状态码） 请求正常处理完毕<br>3XX Redirection（重定向状态码） 需要进行附加的操作以完成请求<br>4XX Client Error（客户端错误状态码） 服务器无法处理请求<br>5XX Server Error（服务端错误状态码） 服务器处理请求出错<br>204：服务器成功处理，但未返回内容。<br>304：Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br>400：Bad Request 客户端请求的语法错误，服务器无法理解<br>403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求<br>404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p>
<h4 id="23-什么是同源：协议相同-域名相同-端口相同"><a href="#23-什么是同源：协议相同-域名相同-端口相同" class="headerlink" title="23.什么是同源：协议相同 域名相同 端口相同"></a>23.什么是同源：协议相同 域名相同 端口相同</h4><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>如果非同源，共有三种行为受到限制。<br>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p>
<h4 id="24-关于建站安全防护"><a href="#24-关于建站安全防护" class="headerlink" title="24.关于建站安全防护"></a>24.关于建站安全防护</h4><p>答：要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。<br>XSS概念:<br>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:<br>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：<br>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：<br>使用验证码，更高级用图灵测试<br>SQL概念：<br>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：<br>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：<br>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的</p>
<h4 id="25-对前端工程化的理解"><a href="#25-对前端工程化的理解" class="headerlink" title="25.对前端工程化的理解"></a>25.对前端工程化的理解</h4><p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具</p>
<h4 id="26-AMD和CMD是什么？它们的区别有哪些？"><a href="#26-AMD和CMD是什么？它们的区别有哪些？" class="headerlink" title="26.AMD和CMD是什么？它们的区别有哪些？"></a>26.AMD和CMD是什么？它们的区别有哪些？</h4><p>AMD和CMD是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的API职责单一，没有全局require，AMD的一个API可以多用。</p>
<h4 id="27-MVC-BFC"><a href="#27-MVC-BFC" class="headerlink" title="27.MVC BFC"></a>27.MVC BFC</h4><p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>
<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>
<h4 id="28-你如何对网站的文件和资源进行优化？"><a href="#28-你如何对网站的文件和资源进行优化？" class="headerlink" title="28.你如何对网站的文件和资源进行优化？"></a>28.你如何对网站的文件和资源进行优化？</h4><p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。</p>
<h4 id="29-如果网页内容需要支持多语言，你会怎么做？"><a href="#29-如果网页内容需要支持多语言，你会怎么做？" class="headerlink" title="29.如果网页内容需要支持多语言，你会怎么做？"></a>29.如果网页内容需要支持多语言，你会怎么做？</h4><p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站</p>
<h4 id="30-如果设计中使用了非标准的字体，你该如何去实现？"><a href="#30-如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="30.如果设计中使用了非标准的字体，你该如何去实现？"></a>30.如果设计中使用了非标准的字体，你该如何去实现？</h4><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等；<a href="http://www.chinaz.com/free/20...；" target="_blank" rel="noopener">http://www.chinaz.com/free/20...；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</p>
<h4 id="31-如何自学一门新编程语言"><a href="#31-如何自学一门新编程语言" class="headerlink" title="31.如何自学一门新编程语言"></a>31.如何自学一门新编程语言</h4><p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目</p>
<h4 id="32-什么是哈希表？"><a href="#32-什么是哈希表？" class="headerlink" title="32.什么是哈希表？"></a>32.什么是哈希表？</h4><p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h4 id="33-静态网页和动态网页区别："><a href="#33-静态网页和动态网页区别：" class="headerlink" title="33.静态网页和动态网页区别："></a>33.静态网页和动态网页区别：</h4><p>静态:网页内容任何人在任何时间访问都是不变的<br>HTML/CSS/JS/视频/音频<br>动态:网页内容不同人在不同时间访问可能是不同的<br>   JSP/PHP/ASP.NET/Node.JS</p>
<h4 id="34-SQL语句的分类"><a href="#34-SQL语句的分类" class="headerlink" title="34.SQL语句的分类"></a>34.SQL语句的分类</h4><p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT</p>
<h4 id="35-什么是弹性布局？"><a href="#35-什么是弹性布局？" class="headerlink" title="35.什么是弹性布局？"></a>35.什么是弹性布局？</h4><p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。<br>设为flex布局以后，子元素的float、clear和vertical-align属性将失效!!!<br>display:flex; 属性align-self 定义子元素的位置。</p>
<h4 id="36-编写响应式？"><a href="#36-编写响应式？" class="headerlink" title="36.编写响应式？"></a>36.编写响应式？</h4><p>1.声明viewport元标签 2.使用流式布局 3.所有容器使用相对尺寸，不用绝对尺寸4.（最重要原则）使用CSS3 Media Query技术</p>
<h4 id="37-常见的浏览器兼容问题？"><a href="#37-常见的浏览器兼容问题？" class="headerlink" title="37.常见的浏览器兼容问题？"></a>37.常见的浏览器兼容问题？</h4><p>1.不同浏览器的标签默认的内.外补丁不同。<br>*{margin:0;padding:0;}<br>2.图片默认有间距<br>使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）<br>margin: 0 auto;<br>4.CSS 兼容前缀<br>-ms- IE<br>-moz- Firefox<br>-o- Opera<br>-webkit- Chrome<br>5.使用CSS Hack<br>如： +:IE6,7的前缀</p>
<p>  -:IE6的前缀</p>
<h4 id="38-H5新特性："><a href="#38-H5新特性：" class="headerlink" title="38.H5新特性："></a>38.H5新特性：</h4><p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）2.（兼容性差,数据8MB,操作简单）sessionStorage 3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。</p>
<h4 id="39-C3新特性："><a href="#39-C3新特性：" class="headerlink" title="39.C3新特性："></a>39.C3新特性：</h4><p>1.复杂的选择器<br>2.弹性布局<br>3.动画</p>
<h4 id="40-什么是typescript"><a href="#40-什么是typescript" class="headerlink" title="40.什么是typescript"></a>40.什么是typescript</h4><p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。<br>TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</p>
<h4 id="41-三大框架的区别："><a href="#41-三大框架的区别：" class="headerlink" title="41.三大框架的区别："></a>41.三大框架的区别：</h4><p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的</p>
<h4 id="42-spa应用"><a href="#42-spa应用" class="headerlink" title="42.spa应用"></a>42.spa应用</h4><p>优点：用户体验好 、良好的前后端分离。<br>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。</p>
<h4 id="43-什么是模块化编程？"><a href="#43-什么是模块化编程？" class="headerlink" title="43.什么是模块化编程？"></a>43.什么是模块化编程？</h4><p>每个模块内部，module变量代表当前模块。<br>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<h4 id="44-性能优化？"><a href="#44-性能优化？" class="headerlink" title="44.性能优化？"></a>44.性能优化？</h4><p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部</p>
<h4 id="45-什么是HTTP协议："><a href="#45-什么是HTTP协议：" class="headerlink" title="45.什么是HTTP协议："></a>45.什么是HTTP协议：</h4><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1和2.0协议的区别：<br>HTTP1.1不支持header数据的压缩，而2.0支持</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy</title>
    <url>/2019/09/03/Proxy/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>Proxy 可以看作是目标对象的一个替身，顶在前面吸收所有操作。</p>
<h4 id="1-Proxy-的写法："><a href="#1-Proxy-的写法：" class="headerlink" title="1. Proxy 的写法："></a>1. Proxy 的写法：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, hanlder);</span><br><span class="line"><span class="comment">// 我们通过 new Proxy() 来生成一个 proxy 的实例 target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。</span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> personA = &#123; <span class="attr">name</span>: <span class="string">'nissen'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> personB = <span class="keyword">new</span> <span class="built_in">Proxy</span>(personA, &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; 666,</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(personB.name);</span><br><span class="line">    // 666</span><br><span class="line">    console.log(personB.age);</span><br><span class="line">    // 666</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-当我们设置的替身对象-handler-为空时，其实对替身的操作就是对原目标的操作："><a href="#2-当我们设置的替身对象-handler-为空时，其实对替身的操作就是对原目标的操作：" class="headerlink" title="2. 当我们设置的替身对象 handler 为空时，其实对替身的操作就是对原目标的操作："></a>2. 当我们设置的替身对象 handler 为空时，其实对替身的操作就是对原目标的操作：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> personA = &#123; </span><br><span class="line">        name: <span class="string">'nissen'</span>,</span><br><span class="line">         age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">        <span class="keyword">const</span> personB = <span class="keyword">new</span> <span class="built_in">Proxy</span>(personA, &#123;&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(personB.name);</span><br><span class="line">        <span class="comment">// nissen</span></span><br><span class="line">        <span class="built_in">console</span>.log(personB.age);</span><br><span class="line">        <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、实例方法"><a href="#二、实例方法" class="headerlink" title="二、实例方法"></a>二、实例方法</h3><h4 id="1-get"><a href="#1-get" class="headerlink" title="1. get()"></a>1. get()</h4><p>用于对目标对象某个属性的读取操作，该方法接受三个参数，依次为目标对象、属性名和 proxy 实例本身（可选）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> personA = &#123;</span><br><span class="line">           name: <span class="string">'nissen'</span>,</span><br><span class="line">           age: <span class="number">18</span>,</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">const</span> personB = <span class="keyword">new</span> <span class="built_in">Proxy</span>(personA, &#123;</span><br><span class="line">           <span class="keyword">get</span>: (target,property,proxy)=&gt;&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">'target'</span>, target, property, proxy);</span><br><span class="line">               <span class="comment">// &#123;name: "nissen", age: 18&#125; name Proxy &#123;name: "nissen", age: 18&#125;</span></span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(target, property) ? <span class="string">`<span class="subst">$&#123;target[property]&#125;</span>_proxy`</span> : <span class="string">'sorry'</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">console</span>.log(personB.name);</span><br><span class="line">       <span class="comment">// nissen_proxy</span></span><br><span class="line">       <span class="built_in">console</span>.log(personB.height);</span><br><span class="line">       <span class="comment">// sorry  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-set"><a href="#2-set" class="headerlink" title="2. set()"></a>2. set()</h4><p>用于对目标对象某个属性的赋值操作，该方法接受四个参数，依次为目标对象、属性名、属性值和 proxy 实例本身（可选）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> personA = &#123;</span><br><span class="line">        name: <span class="string">'nissen'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> personB = <span class="keyword">new</span> <span class="built_in">Proxy</span>(personA,&#123;</span><br><span class="line">        <span class="keyword">set</span>: (target,property,value,proxy)=&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> proxy[property] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    personB.age = <span class="number">19</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(personB.age);</span><br><span class="line">    <span class="comment">// 19</span></span><br><span class="line">    <span class="built_in">console</span>.log(personA.age);</span><br><span class="line">    <span class="comment">// 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-其他实例"><a href="#3-其他实例" class="headerlink" title="3. 其他实例"></a>3. 其他实例</h4><ul>
<li>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值；</li>
<li>deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值；</li>
<li>ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、 Object.getOwnPropertySymbols(proxy)、 Object.keys(proxy)、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)： 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、 Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
<h3 id="三、revocable"><a href="#三、revocable" class="headerlink" title="三、revocable()"></a>三、revocable()</h3><p>Proxy.revocable方法返回一个可取消的 Proxy 实例。目标对象不能直接访问，必须通过替身进行代理，当操作结束之后，替身要进行销毁，收回代理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">const</span> revocableProxy = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">            <span class="keyword">get</span>: () =&gt; 19,</span><br><span class="line">        &#125;);</span><br><span class="line">        const personB = revocableProxy.proxy;</span><br><span class="line">        console.log(personB.age);</span><br><span class="line">        // 19</span><br><span class="line">        revocableProxy.revoke();</span><br><span class="line">        console.log(personB.age);</span><br><span class="line">        // Uncaught TypeError: Cannot perform '<span class="keyword">get</span>' on a proxy that has been revoked at VM5413 Script snippet %2319:54</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>组件生命周期</title>
    <url>/2019/08/30/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>生命周期其实主要分为四个阶段：组件初始化、组件挂载、组件更新、组件卸载。</p>
<h3 id="组件初始化阶段"><a href="#组件初始化阶段" class="headerlink" title="组件初始化阶段"></a>组件初始化阶段</h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>在该阶段组件中的构造方法 constructor() 接收父组件传下来的 props。还可以在 constructor() 内部定义定义this.state 的初始内容。注意：在组件中写了 constructor 方法就必须在里面使用 super()，并且应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props)</span><br><span class="line">  console.log(this.props) // 在内部可以使用props</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    //定义state初始值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件挂载阶段"><a href="#组件挂载阶段" class="headerlink" title="组件挂载阶段"></a>组件挂载阶段</h3><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>在组件将要挂载到 DOM 前调用，只会被调用一次，在该方法中修改 state 的值，并不会引起组件重新渲染。(数据请求等异步操作不建议写在该方法内，异步操作可能阻塞 UI)。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><p>该函数会创建一个虚拟 DOM，用来表示组件的输出。只能通过 this.props 和 this.state 访问数据，且不能在里面执行 this.setState 更该组件状态。在 render 中可以返回 null、false 或者任何 React 组件，只能出现一个顶级组件，不能返回一组元素(在 react16 中有所改善，可以返回一组元素或单个字符串)。</p>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>组件挂载到 Dom 后调用，且只调用一次。此时组件已经生成对应的 DOM 结构，可以在该函数中通过ReactDOM.findDOMNode()访问到真实的 DOM 或者通过 this.refs.[refName] 属性获取真实 DOM 。(数据请求等异步操作建议写在该方法内)</p>
<h3 id="组件更新阶段"><a href="#组件更新阶段" class="headerlink" title="组件更新阶段"></a>组件更新阶段</h3><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>该函数接受一个参数 nextProps,当父组件重传props时会调用。拿到新的 props 与旧的 props 来比较是否变化，若变化可以通过 this.setState 更新 state。当然也可以不比较新旧 props 值直接更新 state。<br>官方提示：在componentWillReceiveProps中调用 this.setState() 将不会引起第二次渲染。<br>由于每次子组件接收到新的props，都会重新渲染一次，除非你使用 shouldComponentUpdate 来阻止重新渲染，但是你可以 componentWillReceiveProps 中根据新的 props 更新 state，虽然更新state也会触发一次重新渲染，但并不会触发额外的render。</p>
<h4 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h4><p>该函数是唯一可以控制组件渲染的生命周期。如果 props 和 state 的改变不需要重新渲染组件。则可以在该函数内返回 false，阻止组件的重新渲染。为了优化组件性能，减少组件的不必要渲染。</p>
<h4 id="componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate(nextProps,nextState)"></a>componentWillUpdate(nextProps,nextState)</h4><p>shouldComponentUpdate 方法返回 true 后，在组件即将进行重新渲染前调用该函数(注意不要里面去更新 props 或者 state，会导致组件进入死循环),在这之后会调用 render 方法进行重新渲染。</p>
<h4 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps,prevState)"></a>componentDidUpdate(prevProps,prevState)</h4><p>组件被重新渲染后该方法会被调用，可以拿到更新前的 props 和 state 。除了首次渲染时调用的componentDidMount，之后每次渲染都会调用该函数。和 componentDidMount 类似的是可以在这里操作更新后的DOM。</p>
<p>###组件卸载阶段</p>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>该函数在组件卸载前被调用，可以在执行一些清理工作，比如清除组件中使用的定时器或者事件监听器，以避免引起内存泄漏。</p>
<hr>
<p>react16的生命周期新引入了三个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate，componentDidCatch,弃用的三个生命周期函数：componentWillMount、componentWillReceiveProps，componentWillUpdate。</p>
<h4 id="getDerivedStateFromProps-props-state"><a href="#getDerivedStateFromProps-props-state" class="headerlink" title="getDerivedStateFromProps(props, state)"></a>getDerivedStateFromProps(props, state)</h4><p>该函数在组件挂载阶段和后续更新阶段调用，根据 props 和 state 两个参数，计算出预期的状态改变，返回一个对象表示新的 state进行更新；如果不需要更新，返回 null 即可。该函数用来替代 componentWillReceiveProps。</p>
<h4 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h4><p>该函数在render之后被调用，可以读取但无法使用DOM的时候。它使得组件能在发生更改之前从 DOM 中捕获一些信息(例如，滚动位置)。返回值将作为componentDidUpdate的第三个参数。该函数配合componentDidUpdate, 可以替代componentWillUpdate。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromError()</span><br></pre></td></tr></table></figure>

<p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state。</p>
<h4 id="componentDidCatch-error，info"><a href="#componentDidCatch-error，info" class="headerlink" title="componentDidCatch(error，info)"></a>componentDidCatch(error，info)</h4><p>任何一处的javascript会触发该函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前最新的生命周期可以总结为：</p>
<ol>
<li>组件挂载阶段<br>constructor<br>getDerivedStateFromProps<br>render<br>componentDidMount</li>
<li>组件更新阶段<br>getDerivedStateFromProps<br>shouldComponentUpdate<br>render<br>getSnapshotBeforeUpdate<br>componentDidUpdate</li>
<li>组件卸载阶段<br>componentWillUnmount</li>
</ol>
<p>参考链接：<br><a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">react官方文档</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React-setState</title>
    <url>/2019/08/23/setState/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;从刚开始接触 React 到现在，听到最多的就是：状态的变更来推动视图的更新。说白了，就是： UI = fun(state)。<br>&nbsp;&nbsp;&nbsp;&nbsp;那 React 什么才能知道需要去重绘视图呢？这就像骑马一样拍他一下（setState）。</p>
<h4 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h4><p>在官方文档中， setState 有以下一段说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setState (</span><br><span class="line">      function|object nextState,</span><br><span class="line">      [function callback]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>所以在实际应用中的用法也是很能满足正常需求的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;, () =&gt; &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  doASomething();</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&#125;, () =&gt; &#123;</span><br><span class="line">  doBSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-调用了-setState-之后干了些什么"><a href="#2-调用了-setState-之后干了些什么" class="headerlink" title="2. 调用了 setState 之后干了些什么"></a>2. 调用了 setState 之后干了些什么</h4><ol>
<li>代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。</li>
<li>经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面；</li>
<li>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；</li>
<li>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</li>
</ol>
<p>这其中调用了4各生命周期函数</p>
<ul>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<h4 id="3-同步与异步"><a href="#3-同步与异步" class="headerlink" title="3. 同步与异步"></a>3. 同步与异步</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在最初刚接触React的时候,我曾一度认为 setState 是异步的，但是偶然间发现一个问题：当我在事件监听的时候调用多次 setState，却发现他们是同步的，后来做了一个测试。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    reactCount: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'testButton'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; <span class="keyword">this</span>.buttonClick())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buttonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="number">2</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reactClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">reactCount</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">reactCount</span>: <span class="number">2</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count, reactCount &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`count`</span>, count);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`reactCount`</span>, reactCount);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="string">`button : <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span>`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;&#123;`react : $&#123;this.state.reactCount&#125;`&#125;&lt;/</span>h1&gt;</span><br><span class="line">        &lt;button id=<span class="string">"testButton"</span>&gt;test&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.reactClick()&#125;&gt;reactCount&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>演示效果：<br><img src="https://github.com/NissenMaster/NissenMaster.github.io/blob/master/images/11201858.gif" alt="11201858.gif"></p>
<p>图片地址：<a href="https://github.com/NissenMaster/NissenMaster.github.io/blob/master/images/11201858.gif" target="_blank" rel="noopener">https://github.com/NissenMaster/NissenMaster.github.io/blob/master/images/11201858.gif</a><br>当点击绑定事件监听的 test 按钮时，数据会依次更新为1,2；而点击 reactCount 的按钮时，数据会直接变更 2。</p>
<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>
<p>更详细的解释可以参考卢卡斯老师（Lucas HC）的一篇文章，挺精髓的：<a href="https://zhuanlan.zhihu.com/p/28905707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28905707</a></p>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title>表驱动法</title>
    <url>/2019/08/22/%E8%A1%A8%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;表驱动方法(Table-Driven Approach)是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或case）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。</p>
<h4 id="1-最简单的数组应用"><a href="#1-最简单的数组应用" class="headerlink" title="1. 最简单的数组应用"></a>1. 最简单的数组应用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;老生常谈的例子: 查询每个月的天数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的 if-else 写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthDays</span>(<span class="params">iMonth, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iDays;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == iMonth) &#123;</span><br><span class="line">  iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == iMonth) &#123;</span><br><span class="line">    iDays = (year % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> !== <span class="number">0</span> || year % <span class="number">400</span> === <span class="number">0</span>) ? <span class="number">29</span> : <span class="number">28</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">4</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">30</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">5</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">6</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">30</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">7</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">8</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">9</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">30</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">11</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">30</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">12</span> == iMonth) &#123;</span><br><span class="line">    iDays = <span class="number">31</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iDays;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 表驱动写法</span></span><br><span class="line"><span class="keyword">const</span> monthDays = [</span><br><span class="line">  [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>],</span><br><span class="line">  [<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMonthDays</span>(<span class="params">month, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isLeapYear = (year % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> !== <span class="number">0</span> || year % <span class="number">400</span> === <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> monthDays[isLeapYear][(month - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最简单的对象应用"><a href="#2-最简单的对象应用" class="headerlink" title="2. 最简单的对象应用"></a>2. 最简单的对象应用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key = <span class="string">"A"</span>) &#123;</span><br><span class="line">   doASomething();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key = <span class="string">"B"</span>) &#123;</span><br><span class="line">    doBSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表驱动就会是这样</span></span><br><span class="line"><span class="keyword">let</span> table = &#123;</span><br><span class="line">  A: &#123;</span><br><span class="line">    data: <span class="string">"111"</span>,</span><br><span class="line">    action: doASomething(),</span><br><span class="line">  &#125;,</span><br><span class="line">  B: &#123;</span><br><span class="line">    data: <span class="string">"111"</span>,</span><br><span class="line">    action: doBSomething(),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTable</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> table[key].action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>书友提供的爱回收面试题</title>
    <url>/2019/08/02/%E7%88%B1%E5%9B%9E%E6%94%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1-堆和栈的理解"><a href="#1-堆和栈的理解" class="headerlink" title="1. 堆和栈的理解"></a>1. 堆和栈的理解</h5><h5 id="2-let、const-和-var-的区别"><a href="#2-let、const-和-var-的区别" class="headerlink" title="2. let、const 和 var 的区别"></a>2. let、const 和 var 的区别</h5><h5 id="3-作用域和执行上下文"><a href="#3-作用域和执行上下文" class="headerlink" title="3. 作用域和执行上下文"></a>3. 作用域和执行上下文</h5><h5 id="4-this-指向以及多重-bind-会改变之前的-this-吗"><a href="#4-this-指向以及多重-bind-会改变之前的-this-吗" class="headerlink" title="4. this 指向以及多重 bind 会改变之前的 this 吗"></a>4. this 指向以及多重 bind 会改变之前的 this 吗</h5><h5 id="5-promise-和-async、await-之间的联系"><a href="#5-promise-和-async、await-之间的联系" class="headerlink" title="5. promise 和 async、await 之间的联系"></a>5. promise 和 async、await 之间的联系</h5><h5 id="6-跨域的方法-后台开启允许跨域的原理以及-jsonp-的园路和缺点"><a href="#6-跨域的方法-后台开启允许跨域的原理以及-jsonp-的园路和缺点" class="headerlink" title="6. 跨域的方法 后台开启允许跨域的原理以及 jsonp 的园路和缺点"></a>6. 跨域的方法 后台开启允许跨域的原理以及 jsonp 的园路和缺点</h5><h5 id="7-vue-双向数据绑定-路由模式"><a href="#7-vue-双向数据绑定-路由模式" class="headerlink" title="7. vue 双向数据绑定  路由模式"></a>7. vue 双向数据绑定  路由模式</h5><h5 id="8-异步事件循环，微任务宏任务"><a href="#8-异步事件循环，微任务宏任务" class="headerlink" title="8. 异步事件循环，微任务宏任务"></a>8. 异步事件循环，微任务宏任务</h5><h5 id="9-如何打包优化包体积"><a href="#9-如何打包优化包体积" class="headerlink" title="9. 如何打包优化包体积"></a>9. 如何打包优化包体积</h5><h5 id="10-jq-源码，实现-css-方法"><a href="#10-jq-源码，实现-css-方法" class="headerlink" title="10. jq 源码，实现 .css 方法"></a>10. jq 源码，实现 .css 方法</h5><h5 id="11-express-和-egg-的区别"><a href="#11-express-和-egg-的区别" class="headerlink" title="11. express 和 egg 的区别"></a>11. express 和 egg 的区别</h5>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
