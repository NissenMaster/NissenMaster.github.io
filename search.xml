<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo 指令]]></title>
    <url>%2F2020%2F03%2F20%2Fhexo-%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. hexo server Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 2. hexo server -s 以静态模式启动 3. hexo server -p 5000更改访问端口 (默认端口为4000，’ctrl + c’关闭server) 4. hexo server -i IP地址自定义 IP 5. hexo clean清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 6. hexo g生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下) 7. hexo d将本地数据部署到远端服务器(如github) 8. hexo init 文件夹名称初始化XX文件夹名称 9. npm update hexo -g升级 10. npm install hexo -g安装 11. node-v查看node.js版本号 12. npm -v查看npm版本号 13. git –version查看git版本号 14. hexo -v查看hexo版本号 15. hexo publish [layout] 通过 publish 命令将草稿移动到 source/_posts 文件夹,如:$ hexo publish [layout] ,草稿默认是不会显示在页面中的，可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true来预览草稿。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dva-loading]]></title>
    <url>%2F2019%2F10%2F22%2Fdva-loading%2F</url>
    <content type="text"><![CDATA[关于页面 loading 的问题，我们最初的方法是手动更新 loading：是在 redux 的 state 中增加 loading 变量，给其设定默认值，当执行调用接口的方法时，先改变一次 loading 的值，执行完成之后再改变一次。这个方法虽然可以解决页面 loading 的问题的，但是这种做法非常的啰嗦且不优雅。于是我们就引入了 dva-loading。dva-loading 其实只是异步执行方法的状态，并不是真正意义上的 loading，我们只是通过异步执行方法的状态给各组件自身控制 loading 渲染提供数据。 具体用法12345678910111213141516171819202122232425// 在 index.js 文件import dva from 'dva';import createLoading from 'dva-loading';const app = dva(&#123;...&#125;);app.use(createLoading());// 示例文件import React, &#123; PureComponent &#125; from 'react';import &#123; connect &#125; from 'dva';@connect((&#123; loading &#125;) =&gt; (&#123; loading: loading.effects['test/fetch'], // 监听单一异步请求状态&#125;))export default class Test extends PureComponent &#123; render() &#123; const &#123; loading &#125; = this.props; return ( &lt;Spin spinning=&#123;loading&#125;&gt; &lt;h1&gt;666666&lt;/h1&gt; &lt;/Spin&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>dva</category>
      </categories>
      <tags>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题一]]></title>
    <url>%2F2019%2F10%2F22%2F%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）1.输入域名地址2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；3.与WEB服务器建立TCP连接；4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）5.浏览器跟踪重定向地址6.服务器处理请求7.服务器返回一个HTTP响应8.浏览器显示 HTML9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）10.浏览器发送异步请求 2.浏览器工作原理1.用户界面 2.网络 3.UI后端 4.数据存储 5.浏览器引擎 6.渲染引擎 7.js解释器 3.浏览器解析过程：流程：解析html以构建dom树-&gt;构建render树-&gt;布局render树-&gt;绘制render树 4.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 5.常见的浏览器内核有哪些？Trident内核：IE,360，傲游，搜狗，世界之窗，腾讯等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 6.请描述一下 cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。存储大小：cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。有期时间：localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 7.请大概描述下页面访问cookie的限制条件跨域问题，设置了HttpOnly。 8.如何实现浏览器内多个标签页之间的通信? (阿里)调用localstorge、cookies等本地存储方式 9.页面可见性（Page Visibility API） 可以有哪些用途？通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 10.网页验证码是做什么的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 11.为什么利用多个域名来存储网站资源？CDN缓存更方便 ，突破浏览器并发限制节约cookie带宽 ，节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 12.谈一下你对网页标准和标准制定机构重要性的理解。网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。 13.知道什么是微格式吗？微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式 优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。 14.一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。（1）图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。（2）如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。（3）如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。（4）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 15.谈谈以前端角度出发做好SEO（搜索引擎）需要考虑什么？合理的标签使用， 主要的互联网目录，链接交换和链接广泛度。 16.请写出一些前端性能优化的方式，越多越好1.减少dom操作2.部署前，图片压缩，代码压缩3.优化js代码结构，减少冗余代码4.减少http请求，合理设置 HTTP缓存5.使用内容分发cdn加速6.静态资源缓存7.图片延迟加载 17.描述一下渐进增强和优雅降级之间的不同?区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 18.webSocket如何兼容低浏览器？(阿里)Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR 19.web开发中会话跟踪的方法有哪些1.cookie 2.session2.url重写 4.隐藏input 5.ip地址 20.HTTP method1.一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。2.GET是最常用的方法，通常用于请求服务器发送某个资源。3.HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分。4.PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它。5.POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。6.TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。7.OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。8.DELETE请求服务器删除请求URL指定的资源。 21.HTTP response报文结构是怎样的rfc2616中进行了定义：1.首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF2.首行之后是若干行响应头，包括：通用头部，响应头部，实体头部3.响应头部和响应实体之间用一个CRLF空行分隔 22.HTTP状态码及其含义状态码类型状态码 类别 原因短语1XX Information（信息性状态码） 接收的请求正在处理2XX Success（成功状态码） 请求正常处理完毕3XX Redirection（重定向状态码） 需要进行附加的操作以完成请求4XX Client Error（客户端错误状态码） 服务器无法处理请求5XX Server Error（服务端错误状态码） 服务器处理请求出错204：服务器成功处理，但未返回内容。304：Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源400：Bad Request 客户端请求的语法错误，服务器无法理解403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 23.什么是同源：协议相同 域名相同 端口相同同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。如果非同源，共有三种行为受到限制。（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 24.关于建站安全防护答：要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。XSS概念:译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。XSS预防:关键cookie字段设置httpOnly输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储CSRF概念：本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。CSRF 预防：使用验证码，更高级用图灵测试SQL概念：通常没有任何过滤，直接把参数存放到了SQL语句当中SQL预防：根本上防止SQL注入的方法，就是参数化查询或者做词法分析。DDOS概念：利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。DDOS预防：用软硬件结合的方式来防御是最有效的 25.对前端工程化的理解1.开发规范2.模块化开发3.组件化开发4.组件仓库5.性能优化6.项目部署7.开发流程8.开发工具 26.AMD和CMD是什么？它们的区别有哪些？AMD和CMD是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的API职责单一，没有全局require，AMD的一个API可以多用。 27.MVC BFCmvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。 BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。 28.你如何对网站的文件和资源进行优化？期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。 29.如果网页内容需要支持多语言，你会怎么做？1.应用字符集的选择，选择UTF-8编码2.语言书写习惯&amp;导航结构3.数据库驱动型网站 30.如果设计中使用了非标准的字体，你该如何去实现？所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。方法：用图片代替web fonts在线字库，如Google Webfonts，Typekit等等；http://www.chinaz.com/free/20...；@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。) 31.如何自学一门新编程语言(1)了解背景知识：历史、现状、特点、应用领域、发展趋势(2)搭建开发环境，编写HelloWorld(3)声明变量和常量(4)数据类型(5)运算符(6)逻辑结构(7)通用小程序(8)函数和对象(9)第三方库、组件、框架(10)实用项目 32.什么是哈希表？散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 33.静态网页和动态网页区别：静态:网页内容任何人在任何时间访问都是不变的HTML/CSS/JS/视频/音频动态:网页内容不同人在不同时间访问可能是不同的 JSP/PHP/ASP.NET/Node.JS 34.SQL语句的分类DDL:数据定义语句 CREATE/DROP/ALTER…DCL:数据控制语句 GRANT…DML:操作操作语句 INSERT/UPDATE/DELETEDQL:查询语句 SELECT 35.什么是弹性布局？解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。设为flex布局以后，子元素的float、clear和vertical-align属性将失效!!!display:flex; 属性align-self 定义子元素的位置。 36.编写响应式？1.声明viewport元标签 2.使用流式布局 3.所有容器使用相对尺寸，不用绝对尺寸4.（最重要原则）使用CSS3 Media Query技术 37.常见的浏览器兼容问题？1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}2.图片默认有间距使用float属性为img布局3.居中问题（而FF默认为左对齐）margin: 0 auto;4.CSS 兼容前缀-ms- IE-moz- Firefox-o- Opera-webkit- Chrome5.使用CSS Hack如： +:IE6,7的前缀 -:IE6的前缀 38.H5新特性：(1)Canvas绘图(2)SVG绘图(3)地理定位(4)Web Workerweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。(5)Web Storage1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）2.（兼容性差,数据8MB,操作简单）sessionStorage 3.localStorage(6)Web SocketWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 39.C3新特性：1.复杂的选择器2.弹性布局3.动画 40.什么是typescript1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。 41.三大框架的区别：Angular带有比较强的排它性的React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。Vue 渐进式的 42.spa应用优点：用户体验好 、良好的前后端分离。缺点：1.不利于SEO。2.初次加载耗时相对增多。3.导航不可用，如果一定要导航需要自行实现前进、后退。 43.什么是模块化编程？每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 44.性能优化？1.使用 CDN2.图片懒加载3.使用外部 JavaScript 和 CSS4.压缩 JavaScript 、 CSS 、字体、图片等5.优化 CSS Sprite6.减少 HTTP 请求数7.减少 DNS 查询8减少 DOM 元素数量9.减少 DOM 操作10.把脚本放在页面底部 45.什么是HTTP协议：HTTP是一个客户端和服务器端请求和应答的标准（TCP）。HTTP1.1和2.0协议的区别：HTTP1.1不支持header数据的压缩，而2.0支持]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy]]></title>
    <url>%2F2019%2F09%2F03%2FProxy%2F</url>
    <content type="text"><![CDATA[一、概念Proxy 可以看作是目标对象的一个替身，顶在前面吸收所有操作。 1. Proxy 的写法：12const proxy = new Proxy(target, hanlder);// 我们通过 new Proxy() 来生成一个 proxy 的实例 target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 使用示例： 12345678910&#123; const personA = &#123; name: 'nissen', age: 18 &#125;; const personB = new Proxy(personA, &#123; get: () =&gt; 666, &#125;); console.log(personB.name); // 666 console.log(personB.age); // 666&#125; 2. 当我们设置的替身对象 handler 为空时，其实对替身的操作就是对原目标的操作：1234567891011&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA, &#123;&#125;); console.log(personB.name); // nissen console.log(personB.age); // 18&#125; 二、实例方法1. get()用于对目标对象某个属性的读取操作，该方法接受三个参数，依次为目标对象、属性名和 proxy 实例本身（可选）。 1234567891011121314151617&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA, &#123; get: (target,property,proxy)=&gt;&#123; console.log('target', target, property, proxy); // &#123;name: "nissen", age: 18&#125; name Proxy &#123;name: "nissen", age: 18&#125; return Reflect.has(target, property) ? `$&#123;target[property]&#125;_proxy` : 'sorry'; &#125; &#125;); console.log(personB.name); // nissen_proxy console.log(personB.height); // sorry &#125; 2. set()用于对目标对象某个属性的赋值操作，该方法接受四个参数，依次为目标对象、属性名、属性值和 proxy 实例本身（可选）。 12345678910111213141516&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA,&#123; set: (target,property,value,proxy)=&gt;&#123; return proxy[property] = value; &#125; &#125;); personB.age = 19; console.log(personB.age); // 19 console.log(personA.age); // 19&#125; 3. 其他实例 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值； deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值； ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、 Object.getOwnPropertySymbols(proxy)、 Object.keys(proxy)、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)： 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、 Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 三、revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。目标对象不能直接访问，必须通过替身进行代理，当操作结束之后，替身要进行销毁，收回代理。 1234567891011&#123; const revocableProxy = Proxy.revocable(&#123;&#125;, &#123; get: () =&gt; 19, &#125;); const personB = revocableProxy.proxy; console.log(personB.age); // 19 revocableProxy.revoke(); console.log(personB.age); // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked at VM5413 Script snippet %2319:54&#125;]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件生命周期]]></title>
    <url>%2F2019%2F08%2F30%2F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期其实主要分为四个阶段：组件初始化、组件挂载、组件更新、组件卸载。 组件初始化阶段constructor在该阶段组件中的构造方法 constructor() 接收父组件传下来的 props。还可以在 constructor() 内部定义定义this.state 的初始内容。注意：在组件中写了 constructor 方法就必须在里面使用 super()，并且应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。 1234567constructor(props) &#123; super(props) console.log(this.props) // 在内部可以使用props this.state = &#123; //定义state初始值 &#125;&#125; 组件挂载阶段componentWillMount在组件将要挂载到 DOM 前调用，只会被调用一次，在该方法中修改 state 的值，并不会引起组件重新渲染。(数据请求等异步操作不建议写在该方法内，异步操作可能阻塞 UI)。 render()该函数会创建一个虚拟 DOM，用来表示组件的输出。只能通过 this.props 和 this.state 访问数据，且不能在里面执行 this.setState 更该组件状态。在 render 中可以返回 null、false 或者任何 React 组件，只能出现一个顶级组件，不能返回一组元素(在 react16 中有所改善，可以返回一组元素或单个字符串)。 componentDidMount组件挂载到 Dom 后调用，且只调用一次。此时组件已经生成对应的 DOM 结构，可以在该函数中通过ReactDOM.findDOMNode()访问到真实的 DOM 或者通过 this.refs.[refName] 属性获取真实 DOM 。(数据请求等异步操作建议写在该方法内) 组件更新阶段componentWillReceiveProps该函数接受一个参数 nextProps,当父组件重传props时会调用。拿到新的 props 与旧的 props 来比较是否变化，若变化可以通过 this.setState 更新 state。当然也可以不比较新旧 props 值直接更新 state。官方提示：在componentWillReceiveProps中调用 this.setState() 将不会引起第二次渲染。由于每次子组件接收到新的props，都会重新渲染一次，除非你使用 shouldComponentUpdate 来阻止重新渲染，但是你可以 componentWillReceiveProps 中根据新的 props 更新 state，虽然更新state也会触发一次重新渲染，但并不会触发额外的render。 shouldComponentUpdate(nextProps,nextState)该函数是唯一可以控制组件渲染的生命周期。如果 props 和 state 的改变不需要重新渲染组件。则可以在该函数内返回 false，阻止组件的重新渲染。为了优化组件性能，减少组件的不必要渲染。 componentWillUpdate(nextProps,nextState)shouldComponentUpdate 方法返回 true 后，在组件即将进行重新渲染前调用该函数(注意不要里面去更新 props 或者 state，会导致组件进入死循环),在这之后会调用 render 方法进行重新渲染。 componentDidUpdate(prevProps,prevState)组件被重新渲染后该方法会被调用，可以拿到更新前的 props 和 state 。除了首次渲染时调用的componentDidMount，之后每次渲染都会调用该函数。和 componentDidMount 类似的是可以在这里操作更新后的DOM。 ###组件卸载阶段 componentWillUnmount该函数在组件卸载前被调用，可以在执行一些清理工作，比如清除组件中使用的定时器或者事件监听器，以避免引起内存泄漏。 react16的生命周期新引入了三个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate，componentDidCatch,弃用的三个生命周期函数：componentWillMount、componentWillReceiveProps，componentWillUpdate。 getDerivedStateFromProps(props, state)该函数在组件挂载阶段和后续更新阶段调用，根据 props 和 state 两个参数，计算出预期的状态改变，返回一个对象表示新的 state进行更新；如果不需要更新，返回 null 即可。该函数用来替代 componentWillReceiveProps。 getSnapshotBeforeUpdate(prevProps, prevState)该函数在render之后被调用，可以读取但无法使用DOM的时候。它使得组件能在发生更改之前从 DOM 中捕获一些信息(例如，滚动位置)。返回值将作为componentDidUpdate的第三个参数。该函数配合componentDidUpdate, 可以替代componentWillUpdate。 1static getDerivedStateFromError() 此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state。 componentDidCatch(error，info)任何一处的javascript会触发该函数。 总结目前最新的生命周期可以总结为： 组件挂载阶段constructorgetDerivedStateFromPropsrendercomponentDidMount 组件更新阶段getDerivedStateFromPropsshouldComponentUpdaterendergetSnapshotBeforeUpdatecomponentDidUpdate 组件卸载阶段componentWillUnmount 参考链接：react官方文档]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-setState]]></title>
    <url>%2F2019%2F08%2F23%2FsetState%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;从刚开始接触 React 到现在，听到最多的就是：状态的变更来推动视图的更新。说白了，就是： UI = fun(state)。&nbsp;&nbsp;&nbsp;&nbsp;那 React 什么才能知道需要去重绘视图呢？这就像骑马一样拍他一下（setState）。 1. 用法在官方文档中， setState 有以下一段说明 1234void setState ( function|object nextState, [function callback]) 所以在实际应用中的用法也是很能满足正常需求的： 123456789101112131415161718// 1this.setState(&#123; count: 1 &#125;);//2this.setState(() =&gt; (&#123; count: 1 &#125;));// 3this.setState(&#123; count: 1 &#125;, () =&gt; &#123; doSomething();&#125;);// 4this.setState(() =&gt; &#123; doASomething(); return &#123; count: 1 &#125;;&#125;, () =&gt; &#123; doBSomething();&#125;); 2. 调用了 setState 之后干了些什么 代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面； 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染； 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 这其中调用了4各生命周期函数 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3. 同步与异步&nbsp;&nbsp;&nbsp;&nbsp;在最初刚接触React的时候,我曾一度认为 setState 是异步的，但是偶然间发现一个问题：当我在事件监听的时候调用多次 setState，却发现他们是同步的，后来做了一个测试。 123456789101112131415161718192021222324252627282930313233343536import React, &#123; PureComponent &#125; from 'react';export default class Demo extends PureComponent &#123; state = &#123; count: 0, reactCount: 0, &#125;; componentDidMount() &#123; document.getElementById('testButton').addEventListener('click', () =&gt; this.buttonClick()) &#125; buttonClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;); this.setState(&#123; count: 2 &#125;); &#125;; reactClick = () =&gt; &#123; this.setState(&#123; reactCount: 1 &#125;); this.setState(&#123; reactCount: 2 &#125;); &#125;; render() &#123; const &#123; count, reactCount &#125; = this.state; console.log(`count`, count); console.log(`reactCount`, reactCount); return ( &lt;&gt; &lt;h1&gt;&#123;`button : $&#123;this.state.count&#125;`&#125;&lt;/h1&gt; &lt;h1&gt;&#123;`react : $&#123;this.state.reactCount&#125;`&#125;&lt;/h1&gt; &lt;button id="testButton"&gt;test&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.reactClick()&#125;&gt;reactCount&lt;/button&gt; &lt;/&gt; ) &#125;&#125; 演示效果： 图片地址：https://github.com/NissenMaster/NissenMaster.github.io/blob/master/images/11201858.gif当点击绑定事件监听的 test 按钮时，数据会依次更新为1,2；而点击 reactCount 的按钮时，数据会直接变更 2。 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 更详细的解释可以参考卢卡斯老师（Lucas HC）的一篇文章，挺精髓的：https://zhuanlan.zhihu.com/p/28905707]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表驱动法]]></title>
    <url>%2F2019%2F08%2F22%2F%E8%A1%A8%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[定义&nbsp;&nbsp;&nbsp;&nbsp;表驱动方法(Table-Driven Approach)是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或case）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。 1. 最简单的数组应用&nbsp;&nbsp;&nbsp;&nbsp;老生常谈的例子: 查询每个月的天数 12345678910111213141516171819202122232425262728293031323334353637383940// 正常的 if-else 写法function getMonthDays(iMonth, year) &#123; let iDays; if (1 == iMonth) &#123; iDays = 31; &#125; else if (2 == iMonth) &#123; iDays = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 29 : 28; &#125; else if (3 == iMonth) &#123; iDays = 31; &#125; else if (4 == iMonth) &#123; iDays = 30; &#125; else if (5 == iMonth) &#123; iDays = 31; &#125; else if (6 == iMonth) &#123; iDays = 30; &#125; else if (7 == iMonth) &#123; iDays = 31; &#125; else if (8 == iMonth) &#123; iDays = 31; &#125; else if (9 == iMonth) &#123; iDays = 30; &#125; else if (10 == iMonth) &#123; iDays = 31; &#125; else if (11 == iMonth) &#123; iDays = 30; &#125; else if (12 == iMonth) &#123; iDays = 31; &#125; return iDays;&#125; // 表驱动写法const monthDays = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]]function getMonthDays(month, year) &#123; let isLeapYear = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 1 : 0 return monthDays[isLeapYear][(month - 1)];&#125; 2. 最简单的对象应用123456789101112131415161718192021if (key = "A") &#123; doASomething();&#125; else if (key = "B") &#123; doBSomething();&#125;// 表驱动就会是这样let table = &#123; A: &#123; data: "111", action: doASomething(), &#125;, B: &#123; data: "111", action: doBSomething(), &#125;&#125;function handleTable(key) &#123; return table[key].action();&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书友提供的爱回收面试题]]></title>
    <url>%2F2019%2F08%2F02%2F%E7%88%B1%E5%9B%9E%E6%94%B6%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 堆和栈的理解2. let、const 和 var 的区别3. 作用域和执行上下文4. this 指向以及多重 bind 会改变之前的 this 吗5. promise 和 async、await 之间的联系6. 跨域的方法 后台开启允许跨域的原理以及 jsonp 的园路和缺点7. vue 双向数据绑定 路由模式8. 异步事件循环，微任务宏任务9. 如何打包优化包体积10. jq 源码，实现 .css 方法11. express 和 egg 的区别]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
