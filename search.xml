<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Proxy]]></title>
    <url>%2F2019%2F09%2F03%2FProxy%2F</url>
    <content type="text"><![CDATA[一、概念Proxy 可以看作是目标对象的一个替身，顶在前面吸收所有操作。 1. Proxy 的写法：12const proxy = new Proxy(target, hanlder);// 我们通过 new Proxy() 来生成一个 proxy 的实例 target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 使用示例： 12345678910&#123; const personA = &#123; name: 'nissen', age: 18 &#125;; const personB = new Proxy(personA, &#123; get: () =&gt; 666, &#125;); console.log(personB.name); // 666 console.log(personB.age); // 666&#125; 2. 当我们设置的替身对象 handler 为空时，其实对替身的操作就是对原目标的操作：1234567891011&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA, &#123;&#125;); console.log(personB.name); // nissen console.log(personB.age); // 18&#125; 二、实例方法1. get()用于对目标对象某个属性的读取操作，该方法接受三个参数，依次为目标对象、属性名和 proxy 实例本身（可选）。 1234567891011121314151617&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA, &#123; get: (target,property,proxy)=&gt;&#123; console.log('target', target, property, proxy); // &#123;name: "nissen", age: 18&#125; name Proxy &#123;name: "nissen", age: 18&#125; return Reflect.has(target, property) ? `$&#123;target[property]&#125;_proxy` : 'sorry'; &#125; &#125;); console.log(personB.name); // nissen_proxy console.log(personB.height); // sorry &#125; 2. set()用于对目标对象某个属性的赋值操作，该方法接受四个参数，依次为目标对象、属性名、属性值和 proxy 实例本身（可选）。 12345678910111213141516&#123; const personA = &#123; name: 'nissen', age: 18, &#125;; const personB = new Proxy(personA,&#123; set: (target,property,value,proxy)=&gt;&#123; return proxy[property] = value; &#125; &#125;); personB.age = 19; console.log(personB.age); // 19 console.log(personA.age); // 19&#125; 3. 其他实例 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值； deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值； ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、 Object.getOwnPropertySymbols(proxy)、 Object.keys(proxy)、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)： 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、 Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 三、revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。目标对象不能直接访问，必须通过替身进行代理，当操作结束之后，替身要进行销毁，收回代理。 1234567891011&#123; const revocableProxy = Proxy.revocable(&#123;&#125;, &#123; get: () =&gt; 19, &#125;); const personB = revocableProxy.proxy; console.log(personB.age); // 19 revocableProxy.revoke(); console.log(personB.age); // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked at VM5413 Script snippet %2319:54&#125;]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件生命周期]]></title>
    <url>%2F2019%2F08%2F30%2F%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期其实主要分为四个阶段：组件初始化、组件挂载、组件更新、组件卸载。 组件初始化阶段constructor在该阶段组件中的构造方法 constructor() 接收父组件传下来的 props。还可以在 constructor() 内部定义定义this.state 的初始内容。注意：在组件中写了 constructor 方法就必须在里面使用 super()，并且应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。 1234567constructor(props) &#123; super(props) console.log(this.props) // 在内部可以使用props this.state = &#123; //定义state初始值 &#125;&#125; 组件挂载阶段componentWillMount在组件将要挂载到 DOM 前调用，只会被调用一次，在该方法中修改 state 的值，并不会引起组件重新渲染。(数据请求等异步操作不建议写在该方法内，异步操作可能阻塞 UI)。 render()该函数会创建一个虚拟 DOM，用来表示组件的输出。只能通过 this.props 和 this.state 访问数据，且不能在里面执行 this.setState 更该组件状态。在 render 中可以返回 null、false 或者任何 React 组件，只能出现一个顶级组件，不能返回一组元素(在 react16 中有所改善，可以返回一组元素或单个字符串)。 componentDidMount组件挂载到 Dom 后调用，且只调用一次。此时组件已经生成对应的 DOM 结构，可以在该函数中通过ReactDOM.findDOMNode()访问到真实的 DOM 或者通过 this.refs.[refName] 属性获取真实 DOM 。(数据请求等异步操作建议写在该方法内) 组件更新阶段componentWillReceiveProps该函数接受一个参数 nextProps,当父组件重传props时会调用。拿到新的 props 与旧的 props 来比较是否变化，若变化可以通过 this.setState 更新 state。当然也可以不比较新旧 props 值直接更新 state。官方提示：在componentWillReceiveProps中调用 this.setState() 将不会引起第二次渲染。由于每次子组件接收到新的props，都会重新渲染一次，除非你使用 shouldComponentUpdate 来阻止重新渲染，但是你可以 componentWillReceiveProps 中根据新的 props 更新 state，虽然更新state也会触发一次重新渲染，但并不会触发额外的render。 shouldComponentUpdate(nextProps,nextState)该函数是唯一可以控制组件渲染的生命周期。如果 props 和 state 的改变不需要重新渲染组件。则可以在该函数内返回 false，阻止组件的重新渲染。为了优化组件性能，减少组件的不必要渲染。 componentWillUpdate(nextProps,nextState)shouldComponentUpdate 方法返回 true 后，在组件即将进行重新渲染前调用该函数(注意不要里面去更新 props 或者 state，会导致组件进入死循环),在这之后会调用 render 方法进行重新渲染。 componentDidUpdate(prevProps,prevState)组件被重新渲染后该方法会被调用，可以拿到更新前的 props 和 state 。除了首次渲染时调用的componentDidMount，之后每次渲染都会调用该函数。和 componentDidMount 类似的是可以在这里操作更新后的DOM。 ###组件卸载阶段 componentWillUnmount该函数在组件卸载前被调用，可以在执行一些清理工作，比如清除组件中使用的定时器或者事件监听器，以避免引起内存泄漏。 react16的生命周期新引入了三个新的生命周期函数：getDerivedStateFromProps，getSnapshotBeforeUpdate，componentDidCatch,弃用的三个生命周期函数：componentWillMount、componentWillReceiveProps，componentWillUpdate。 getDerivedStateFromProps(props, state)该函数在组件挂载阶段和后续更新阶段调用，根据 props 和 state 两个参数，计算出预期的状态改变，返回一个对象表示新的 state进行更新；如果不需要更新，返回 null 即可。该函数用来替代 componentWillReceiveProps。 getSnapshotBeforeUpdate(prevProps, prevState)该函数在render之后被调用，可以读取但无法使用DOM的时候。它使得组件能在发生更改之前从 DOM 中捕获一些信息(例如，滚动位置)。返回值将作为componentDidUpdate的第三个参数。该函数配合componentDidUpdate, 可以替代componentWillUpdate。 1static getDerivedStateFromError() 此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state。 componentDidCatch(error，info)任何一处的javascript会触发该函数。 总结目前最新的生命周期可以总结为： 组件挂载阶段constructorgetDerivedStateFromPropsrendercomponentDidMount 组件更新阶段getDerivedStateFromPropsshouldComponentUpdaterendergetSnapshotBeforeUpdatecomponentDidUpdate 组件卸载阶段componentWillUnmount 参考链接：react官方文档]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-setState]]></title>
    <url>%2F2019%2F08%2F23%2FsetState%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;从刚开始接触 React 到现在，听到最多的就是：状态的变更来推动视图的更新。说白了，就是： UI = fun(state)。&nbsp;&nbsp;&nbsp;&nbsp;那 React 什么才能知道需要去重绘视图呢？这就像骑马一样拍他一下（setState）。 1. 用法在官方文档中， setState 有以下一段说明 1234void setState ( function|object nextState, [function callback]) 所以在实际应用中的用法也是很能满足正常需求的： 123456789101112131415161718// 1this.setState(&#123; count: 1 &#125;);//2this.setState(() =&gt; (&#123; count: 1 &#125;));// 3this.setState(&#123; count: 1 &#125;, () =&gt; &#123; doSomething();&#125;);// 4this.setState(() =&gt; &#123; doASomething(); return &#123; count: 1 &#125;;&#125;, () =&gt; &#123; doBSomething();&#125;); 2. 调用了 setState 之后干了些什么 代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面； 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染； 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 这其中调用了4各生命周期函数 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3. 同步与异步&nbsp;&nbsp;&nbsp;&nbsp;在最初刚接触React的时候,我曾一度认为 setState 是异步的，但是偶然间发现一个问题：当我在事件监听的时候调用多次 setState，却发现他们是同步的，后来做了一个测试。 123456789101112131415161718192021222324252627282930313233343536import React, &#123; PureComponent &#125; from 'react';export default class Demo extends PureComponent &#123; state = &#123; count: 0, reactCount: 0, &#125;; componentDidMount() &#123; document.getElementById('testButton').addEventListener('click', () =&gt; this.buttonClick()) &#125; buttonClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;); this.setState(&#123; count: 2 &#125;); &#125;; reactClick = () =&gt; &#123; this.setState(&#123; reactCount: 1 &#125;); this.setState(&#123; reactCount: 2 &#125;); &#125;; render() &#123; const &#123; count, reactCount &#125; = this.state; console.log(`count`, count); console.log(`reactCount`, reactCount); return ( &lt;&gt; &lt;h1&gt;&#123;`button : $&#123;this.state.count&#125;`&#125;&lt;/h1&gt; &lt;h1&gt;&#123;`react : $&#123;this.state.reactCount&#125;`&#125;&lt;/h1&gt; &lt;button id="testButton"&gt;test&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.reactClick()&#125;&gt;reactCount&lt;/button&gt; &lt;/&gt; ) &#125;&#125; 演示效果： 图片地址：https://github.com/NissenMaster/NissenMaster.github.io/blob/master/images/11201858.gif当点击绑定事件监听的 test 按钮时，数据会依次更新为1,2；而点击 reactCount 的按钮时，数据会直接变更 2。 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 更详细的解释可以参考卢卡斯老师（Lucas HC）的一篇文章，挺精髓的：https://zhuanlan.zhihu.com/p/28905707]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表驱动法]]></title>
    <url>%2F2019%2F08%2F22%2F%E8%A1%A8%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[定义&nbsp;&nbsp;&nbsp;&nbsp;表驱动方法(Table-Driven Approach)是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或case）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。 1. 最简单的数组应用&nbsp;&nbsp;&nbsp;&nbsp;老生常谈的例子: 查询每个月的天数 12345678910111213141516171819202122232425262728293031323334353637383940// 正常的 if-else 写法function getMonthDays(iMonth, year) &#123; let iDays; if (1 == iMonth) &#123; iDays = 31; &#125; else if (2 == iMonth) &#123; iDays = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 29 : 28; &#125; else if (3 == iMonth) &#123; iDays = 31; &#125; else if (4 == iMonth) &#123; iDays = 30; &#125; else if (5 == iMonth) &#123; iDays = 31; &#125; else if (6 == iMonth) &#123; iDays = 30; &#125; else if (7 == iMonth) &#123; iDays = 31; &#125; else if (8 == iMonth) &#123; iDays = 31; &#125; else if (9 == iMonth) &#123; iDays = 30; &#125; else if (10 == iMonth) &#123; iDays = 31; &#125; else if (11 == iMonth) &#123; iDays = 30; &#125; else if (12 == iMonth) &#123; iDays = 31; &#125; return iDays;&#125; // 表驱动写法const monthDays = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]]function getMonthDays(month, year) &#123; let isLeapYear = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 1 : 0 return monthDays[isLeapYear][(month - 1)];&#125; 2. 最简单的对象应用123456789101112131415161718192021if (key = "A") &#123; doASomething();&#125; else if (key = "B") &#123; doBSomething();&#125;// 表驱动就会是这样let table = &#123; A: &#123; data: "111", action: doASomething(), &#125;, B: &#123; data: "111", action: doBSomething(), &#125;&#125;function handleTable(key) &#123; return table[key].action();&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书友提供的爱回收面试题]]></title>
    <url>%2F2019%2F08%2F02%2F123%2F</url>
    <content type="text"><![CDATA[1. 堆和栈的理解2. let、const 和 var 的区别3. 作用域和执行上下文4. this 指向以及多重 bind 会改变之前的 this 吗5. promise 和 async、await 之间的联系6. 跨域的方法 后台开启允许跨域的原理以及 jsonp 的园路和缺点7. vue 双向数据绑定 路由模式8. 异步事件循环，微任务宏任务9. 如何打包优化包体积10. jq 源码，实现 .css 方法11. express 和 egg 的区别]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
