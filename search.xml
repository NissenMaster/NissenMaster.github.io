<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React 的马鞭 setState]]></title>
    <url>%2F2019%2F08%2F23%2FsetState-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;从刚开始接触 React 到现在，听到最多的就是：状态的变更来推动视图的更新。说白了，就是： UI = fun(state)。&nbsp;&nbsp;&nbsp;&nbsp;那 React 什么才能知道需要去重绘视图呢？这就像骑马一样拍他一下（setState）。 1. 怎么拍在官方文档中， setState 有以下一段说明 1234void setState ( function|object nextState, [function callback]) 所以在实际应用中的用法也是很能满足正常需求的： 123456789101112131415161718// 1this.setState(&#123; count: 1 &#125;);//2this.setState(() =&gt; (&#123; count: 1 &#125;));// 3this.setState(&#123; count: 1 &#125;, () =&gt; &#123; doSomething();&#125;);// 4this.setState(() =&gt; &#123; doASomething(); return &#123; count: 1 &#125;;&#125;, () =&gt; &#123; doBSomething();&#125;); 2. 拍打之后的事情调用了 setState 之后干了些什么 代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面； 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染； 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 这其中调用了4各生命周期函数 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3. 同步与异步&nbsp;&nbsp;&nbsp;&nbsp;在最初刚接触React的时候,我曾一度认为 setState 是异步的，但是偶然间发现一个问题：当我在事件监听的时候调用多次 setState，却发现他们是同步的，后来做了一个测试。 123456789101112131415161718192021222324252627282930313233343536import React, &#123; PureComponent &#125; from 'react';export default class Demo extends PureComponent &#123; state = &#123; count: 0, reactCount: 0, &#125;; componentDidMount() &#123; document.getElementById('testButton').addEventListener('click', () =&gt; this.buttonClick()) &#125; buttonClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;); this.setState(&#123; count: 2 &#125;); &#125;; reactClick = () =&gt; &#123; this.setState(&#123; reactCount: 1 &#125;); this.setState(&#123; reactCount: 2 &#125;); &#125;; render() &#123; const &#123; count, reactCount &#125; = this.state; console.log(`count`, count); console.log(`reactCount`, reactCount); return ( &lt;&gt; &lt;h1&gt;&#123;`button : $&#123;this.state.count&#125;`&#125;&lt;/h1&gt; &lt;h1&gt;&#123;`react : $&#123;this.state.reactCount&#125;`&#125;&lt;/h1&gt; &lt;button id="testButton"&gt;test&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.reactClick()&#125;&gt;reactCount&lt;/button&gt; &lt;/&gt; ) &#125;&#125; 演示效果： 图片显示有点问题，当点击绑定事件监听的 test 按钮时，数据会依次更新为1,2；而点击 reactCount 的按钮时，数据会直接变更 2。 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 更详细的解释可以参考卢卡斯老师（Lucas HC）的一篇文章，挺精髓的：https://zhuanlan.zhihu.com/p/28905707]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>setState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表驱动法]]></title>
    <url>%2F2019%2F08%2F22%2F%E8%A1%A8%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[定义&nbsp;&nbsp;&nbsp;&nbsp;表驱动方法(Table-Driven Approach)是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或case）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。 1. 最简单的数组应用&nbsp;&nbsp;&nbsp;&nbsp;老生常谈的例子: 查询每个月的天数 12345678910111213141516171819202122232425262728293031323334353637383940// 正常的 if-else 写法function getMonthDays(iMonth, year) &#123; let iDays; if (1 == iMonth) &#123; iDays = 31; &#125; else if (2 == iMonth) &#123; iDays = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 29 : 28; &#125; else if (3 == iMonth) &#123; iDays = 31; &#125; else if (4 == iMonth) &#123; iDays = 30; &#125; else if (5 == iMonth) &#123; iDays = 31; &#125; else if (6 == iMonth) &#123; iDays = 30; &#125; else if (7 == iMonth) &#123; iDays = 31; &#125; else if (8 == iMonth) &#123; iDays = 31; &#125; else if (9 == iMonth) &#123; iDays = 30; &#125; else if (10 == iMonth) &#123; iDays = 31; &#125; else if (11 == iMonth) &#123; iDays = 30; &#125; else if (12 == iMonth) &#123; iDays = 31; &#125; return iDays;&#125; // 表驱动写法const monthDays = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]]function getMonthDays(month, year) &#123; let isLeapYear = (year % 4 === 0) &amp;&amp; (year % 100 !== 0 || year % 400 === 0) ? 1 : 0 return monthDays[isLeapYear][(month - 1)];&#125; 2. 最简单的对象应用123456789101112131415161718192021if (key = "A") &#123; doASomething();&#125; else if (key = "B") &#123; doBSomething();&#125;// 表驱动就会是这样let table = &#123; A: &#123; data: "111", action: doASomething(), &#125;, B: &#123; data: "111", action: doBSomething(), &#125;&#125;function handleTable(key) &#123; return table[key].action();&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书友提供的爱回收面试题]]></title>
    <url>%2F2019%2F08%2F02%2F123%2F</url>
    <content type="text"><![CDATA[1. 堆和栈的理解2. let、const 和 var 的区别3. 作用域和执行上下文4. this 指向以及多重 bind 会改变之前的 this 吗5. promise 和 async、await 之间的联系6. 跨域的方法 后台开启允许跨域的原理以及 jsonp 的园路和缺点7. vue 双向数据绑定 路由模式8. 异步事件循环，微任务宏任务9. 如何打包优化包体积10. jq 源码，实现 .css 方法11. express 和 egg 的区别]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
